import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
  createMockFirestore,
  createMockDocumentSnapshot,
  createMockQuerySnapshot,
} from '../../__tests__/mocks';

vi.mock('firebase-admin/firestore');
vi.mock('firebase-admin');
vi.mock('../../common/auditLogger', () => ({
  AUDIT_EVENT_TYPES: {
    SESSION_HEARTBEAT: 'SESSION_HEARTBEAT',
    DAILY_LIMIT_REACHED: 'DAILY_LIMIT_REACHED',
  },
}));

let getAuditLogs, getAuditLogStats, getUserAuditTrail;
let mockDb;

describe('Audit Functions', () => {
  let mockUserDoc;

  beforeEach(async () => {
    vi.clearAllMocks();
    mockDb = createMockFirestore();
    
    const mockFirestore = await import('firebase-admin/firestore');
    mockFirestore.getFirestore.mockReturnValue(mockDb);
    
    const auditModule = await import('../auditFunctions');
    getAuditLogs = auditModule.getAuditLogs;
    getAuditLogStats = auditModule.getAuditLogStats;
    getUserAuditTrail = auditModule.getUserAuditTrail;
    
    mockUserDoc = createMockDocumentSnapshot({
      userId: 'user-123',
      displayName: 'John Admin',
      role: 'dmv_admin',
    }, true);
  });

  describe('getAuditLogs', () => {
    it('should throw error if user not authenticated', async () => {
      const request = { data: {}, auth: null };

      try {
        await getAuditLogs(request);
        expect(true).toBe(false);
      } catch (error) {
        expect(error.message).toContain('UNAUTHENTICATED');
      }
    });

    it('should throw error if user not found', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(
            createMockDocumentSnapshot({}, false)
          )),
        }))
      }));

      const request = { data: {}, auth: { uid: 'user-123' } };

      try {
        await getAuditLogs(request);
        expect(true).toBe(false);
      } catch (error) {
        expect(error.message).toContain('NOT_FOUND');
      }
    });

    it('should return empty logs when none found', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        })),
        where: vi.fn().mockReturnThis(),
        get: vi.fn(() => Promise.resolve(createMockQuerySnapshot([])))
      }));

      const request = {
        data: { filters: {}, limit: 100, offset: 0 },
        auth: { uid: 'user-123' }
      };

      const result = await getAuditLogs(request);
      expect(result.logs).toHaveLength(0);
      expect(result.totalCount).toBe(0);
    });

    it('should apply filters correctly', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        })),
        where: vi.fn().mockReturnThis(),
        get: vi.fn(() => Promise.resolve(createMockQuerySnapshot([
          {
            id: 'log-123',
            data: () => ({
              userId: 'user-123',
              action: 'SESSION_HEARTBEAT',
              resource: 'compliance',
              status: 'success'
            })
          }
        ]))
      }));

      const request = {
        data: {
          filters: {
            userId: 'user-123',
            action: 'SESSION_HEARTBEAT'
          },
          limit: 100,
          offset: 0
        },
        auth: { uid: 'user-123' }
      };

      const result = await getAuditLogs(request);
      expect(result.logs.length).toBeGreaterThanOrEqual(0);
    });

    it('should respect pagination limit', async () => {
      const logs = Array(150).fill(null).map((_, i) => ({
        id: `log-${i}`,
        data: () => ({ action: 'TEST', status: 'success' })
      }));

      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        })),
        where: vi.fn().mockReturnThis(),
        get: vi.fn(() => Promise.resolve(createMockQuerySnapshot(logs)))
      }));

      const request = {
        data: { limit: 50, offset: 0 },
        auth: { uid: 'user-123' }
      };

      const result = await getAuditLogs(request);
      expect(result.logs.length).toBeLessThanOrEqual(50);
    });
  });

  describe('getAuditLogStats', () => {
    it('should throw error if user not authenticated', async () => {
      const request = { data: {}, auth: null };

      try {
        await getAuditLogStats(request);
        expect(true).toBe(false);
      } catch (error) {
        expect(error.message).toContain('UNAUTHENTICATED');
      }
    });

    it('should throw error if startDate missing', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        }))
      }));

      const request = {
        data: { endDate: new Date() },
        auth: { uid: 'user-123' }
      };

      try {
        await getAuditLogStats(request);
        expect(true).toBe(false);
      } catch (error) {
        expect(error.message).toContain('BAD_REQUEST');
      }
    });

    it('should aggregate stats by status', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        })),
        where: vi.fn().mockReturnThis(),
        get: vi.fn(() => Promise.resolve(createMockQuerySnapshot([
          { id: 'log-1', data: () => ({ status: 'success', action: 'LOGIN', resource: 'user' }) },
          { id: 'log-2', data: () => ({ status: 'success', action: 'VIEW', resource: 'audit' }) },
          { id: 'log-3', data: () => ({ status: 'error', action: 'DELETE', resource: 'user' }) }
        ])))
      }));

      const request = {
        data: {
          startDate: new Date('2024-01-01'),
          endDate: new Date('2024-12-31')
        },
        auth: { uid: 'user-123' }
      };

      const result = await getAuditLogStats(request);
      expect(result.stats.byStatus.success).toBe(2);
      expect(result.stats.byStatus.error).toBe(1);
    });
  });

  describe('getUserAuditTrail', () => {
    it('should throw error if user not authenticated', async () => {
      const request = { data: {}, auth: null };

      try {
        await getUserAuditTrail(request);
        expect(true).toBe(false);
      } catch (error) {
        expect(error.message).toContain('UNAUTHENTICATED');
      }
    });

    it('should return user audit trail in reverse chronological order', async () => {
      mockDb.collection = vi.fn(() => ({
        doc: vi.fn(() => ({
          get: vi.fn(() => Promise.resolve(mockUserDoc))
        })),
        where: vi.fn().mockReturnThis(),
        get: vi.fn(() => Promise.resolve(createMockQuerySnapshot([
          {
            id: 'log-1',
            data: () => ({
              userId: 'target-user',
              action: 'LOGIN',
              timestamp: { toMillis: () => 1000 }
            })
          },
          {
            id: 'log-2',
            data: () => ({
              userId: 'target-user',
              action: 'LOGOUT',
              timestamp: { toMillis: () => 2000 }
            })
          }
        ])))
      }));

      const request = {
        data: { targetUserId: 'target-user' },
        auth: { uid: 'user-123' }
      };

      const result = await getUserAuditTrail(request);
      expect(result.trail.length).toBeGreaterThan(0);
      expect(result.count).toBeGreaterThan(0);
    });
  });
});
